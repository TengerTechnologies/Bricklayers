import re
import sys
import logging
import argparse


class BricklayeringProcessor:
    def __init__(self, layer_height=0.2):
        self.layer_height = layer_height
        self.current_z = 0.0
        self.current_layer = 0
        self.current_section = "perimeter"
        self.extrusion_mode = "absolute"

        self.perimeter_types = {
            "Custom",
            "Skirt/Brim",
            "Support material",
            "External perimeter",
            "Perimeter",
            "Overhang perimeter",
        }
        self.non_perimeter_types = {
            "Solid infill",
            "Internal infill",
            "Top solid infill",
            "Bridge infill",
        }

    def process_line(self, line):
        output = []
        original_line = line.strip()

        # Update Z position and layer
        if line.startswith("G1 ") and "Z" in line:
            z_match = re.search(r"Z([\d.]+)", line)
            if z_match:
                self.current_z = float(z_match.group(1))
                self.current_layer = int(round(self.current_z / self.layer_height))
                logging.debug(f"Layer update: {self.current_layer}, Z={self.current_z}")

        # Handle extrusion mode changes
        if line.startswith("M82"):
            self.extrusion_mode = "absolute"
        elif line.startswith("M83"):
            self.extrusion_mode = "relative"

        # Handle section type changes
        if line.startswith(";TYPE:"):
            section_type = line.split(":")[-1].strip()
            new_section = (
                "non_perimeter"
                if section_type in self.non_perimeter_types
                else "perimeter"
            )

            if new_section != self.current_section:
                self.handle_section_change(new_section, output)
                self.current_section = new_section

        # Process extrusion moves
        if "E" in line and self.current_section == "non_perimeter":
            line = self.adjust_extrusion(line)

        output.append(line)
        return output

    def handle_section_change(self, new_section, output):
        base_z = self.current_layer * self.layer_height
        if self.current_layer < 1:
            return

        # Exiting non-perimeter
        if self.current_section == "non_perimeter" and new_section == "perimeter":
            if self.current_layer >= 2:
                output.append(f"G1 Z{base_z:.3f} F9000 ; Reset to perimeter height\n")

        # Entering non-perimeter
        elif new_section == "non_perimeter":
            if self.current_layer == 1:
                logging.debug("First layer non-perimeter - extrusion adjustment only")
            elif self.current_layer >= 2:
                new_z = base_z + 0.1
                output.append(f"G1 Z{new_z:.3f} F9000 ; Non-perimeter height shift\n")

    def adjust_extrusion(self, line):
        if self.current_layer != 1:
            return line  # Only adjust first layer non-perimeter

        e_match = re.search(r"E([\d.]+)", line)
        if not e_match:
            return line

        e_value = float(e_match.group(1))
        if self.extrusion_mode == "absolute":
            new_e = e_value * 1.5
        else:
            new_e = e_value * 1.5

        return re.sub(r"E[\d.]+", f"E{new_e:.5f}", line)

    def process_file(self, input_path, output_path):
        with open(input_path, "r") as infile, open(output_path, "w") as outfile:
            for line in infile:
                processed = self.process_line(line)
                outfile.writelines(processed)


def main():
    parser = argparse.ArgumentParser(description="Bricklayering GCode Post-Processor")
    parser.add_argument(
        "gcode_file", help="Path to the G-code file generated by PrusaSlicer"
    )
    parser.add_argument(
        "--layer-height", type=float, required=True, help="Layer height in mm"
    )
    args = parser.parse_args()

    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(levelname)s - %(message)s",
        filename="bricklayer.log",
        filemode="a",
    )

    try:
        processor = BricklayeringProcessor(layer_height=args.layer_height)
        # Read the input file
        with open(args.gcode_file, "r") as f:
            lines = f.readlines()

        # Process each line
        processed_lines = []
        for line in lines:
            processed = processor.process_line(line)
            processed_lines.extend(processed)

        # Write back to the same file
        with open(args.gcode_file, "w") as f:
            f.writelines(processed_lines)

        logging.info(f"Successfully processed {args.gcode_file}")
    except Exception as e:
        logging.error(f"Failed to process file: {str(e)}")
        sys.exit(1)


if __name__ == "__main__":
    main()
